## 一、状态管理改动（核心改动）

### 问题分析
当前使用全局变量 `_game_instance` 存储单个游戏实例，多人对战时会出现：
- 所有玩家共享同一个游戏状态
- 无法同时进行多局游戏
- 并发访问不安全

### 解决方案
将单例改为基于 `game_id` 的字典映射，每个游戏有独立实例。

### 1. 修改 `tools/gomoku_game.py`

**改动说明**：
- 将 `_game_instance` 改为 `_game_instances: Dict[str, GomokuBoard]`，用 `game_id` 作为键
- 添加 `asyncio.Lock` 保证并发安全
- 所有函数改为异步，并添加 `game_id` 参数
- `get_current_board()` 改为 `get_game_board(game_id)`

**代码改动**：
```python
# 改动前：全局单例
_game_instance: Optional[GomokuBoard] = None

def get_current_board() -> GomokuBoard:
    global _game_instance
    if _game_instance is None:
        _game_instance = GomokuBoard()
    return _game_instance

def init_game(size: int = 15) -> str:
    global _game_instance
    _game_instance = GomokuBoard(size)
    return f"已初始化 {size}x{size} 五子棋游戏..."
```

```python
# 改动后：字典映射 + 异步 + 锁
from typing import Dict
import asyncio

# 改为字典，key是game_id，value是GomokuBoard实例
_game_instances: Dict[str, GomokuBoard] = {}
_game_lock = asyncio.Lock()  # 并发锁，保证线程安全

async def get_game_board(game_id: str) -> GomokuBoard:
    """根据game_id获取游戏实例"""
    async with _game_lock:  # 加锁，防止并发访问冲突
        if game_id not in _game_instances:
            raise ValueError(f"Game {game_id} not found")
        return _game_instances[game_id]

async def init_game(game_id: str, size: int = 15) -> str:
    """初始化新游戏，需要传入game_id"""
    async with _game_lock:
        if game_id in _game_instances:
            return f"游戏 {game_id} 已存在"
        _game_instances[game_id] = GomokuBoard(size)
        return f"已初始化游戏 {game_id}，{size}x{size} 棋盘"

async def remove_game(game_id: str):
    """删除游戏实例（游戏结束后清理）"""
    async with _game_lock:
        if game_id in _game_instances:
            del _game_instances[game_id]

async def make_move(game_id: str, row: int, col: int) -> str:
    """走子函数，需要传入game_id指定是哪个游戏"""
    board = await get_game_board(game_id)  # 先获取对应的游戏实例
    
    if board.game_over:
        return "游戏已结束，无法继续走子"
    
    player_who_moved = board.current_player
    
    if not board.make_move(row, col):
        return f"无效走子：位置 ({row}, {col}) 已被占用或超出边界"
    
    player_name = "黑棋" if player_who_moved == Player.BLACK else "白棋"
    result = f"{player_name}在位置 ({row}, {col}) 落子成功"
    
    if board.game_over:
        winner_name = "黑棋" if board.winner == Player.BLACK else "白棋"
        result += f"\n\n【重要】游戏结束！{winner_name}获胜！"
    else:
        next_player = "黑棋" if board.current_player == Player.BLACK else "白棋"
        result += f"\n下一步轮到 {next_player}"
        result += f"\n当前棋盘上共有 {len(board.move_history)} 个棋子"
    
    return result

async def get_board_state(game_id: str) -> str:
    """获取游戏状态，需要传入game_id"""
    board = await get_game_board(game_id)
    return board.get_board_state()
```

- 所有函数都需要 `game_id` 参数

---

## 二、房间管理系统（新增模块）

### 设计说明
房间管理用于：
- 管理游戏房间的创建、加入、退出
- 维护房间与游戏的映射关系
- 管理房间内的玩家列表和状态

### 2. 新建 `core/room_manager.py`

**设计思路**：
- `Room` 数据类：房间ID、游戏ID、玩家列表、状态等
- `RoomManager` 类：管理房间的增删改查
- 使用异步锁保证并发安全

**代码实现**：
```python
from dataclasses import dataclass
from typing import List, Optional, Dict
from datetime import datetime
from enum import Enum
import asyncio

class RoomStatus(Enum):
    """房间状态枚举"""
    WAITING = "waiting"    # 等待玩家加入
    PLAYING = "playing"    # 游戏中
    FINISHED = "finished"  # 已结束

@dataclass
class Room:
    """房间数据类，存储房间的所有信息"""
    room_id: str           # 房间ID
    game_id: str           # 对应的游戏ID
    creator_id: str        # 创建者ID
    players: List[str]     # 玩家ID列表
    spectators: List[str]  # 观战者ID列表
    status: RoomStatus     # 房间状态
    created_at: datetime   # 创建时间
    settings: dict         # 房间设置（棋盘大小、AI难度等）

class RoomManager:
    """房间管理器，负责管理所有房间"""
    
    def __init__(self):
        self._rooms: Dict[str, Room] = {}  # room_id -> Room
        self._lock = asyncio.Lock()        # 并发锁
    
    async def create_room(self, room_id: str, creator_id: str, 
                         game_id: str, max_players: int = 2) -> Room:
        """创建新房间"""
        async with self._lock:
            if room_id in self._rooms:
                raise ValueError(f"Room {room_id} already exists")
            
            room = Room(
                room_id=room_id,
                game_id=game_id,
                creator_id=creator_id,
                players=[creator_id],  # 创建者自动加入
                spectators=[],
                status=RoomStatus.WAITING,
                created_at=datetime.now(),
                settings={"max_players": max_players}
            )
            self._rooms[room_id] = room
            return room
    
    async def join_room(self, room_id: str, user_id: str) -> Room:
        """玩家加入房间"""
        async with self._lock:
            if room_id not in self._rooms:
                raise ValueError(f"Room {room_id} not found")
            
            room = self._rooms[room_id]
            
            # 如果玩家已经在房间中，直接返回
            if user_id in room.players:
                return room
            
            # 检查房间是否已满
            if len(room.players) >= room.settings["max_players"]:
                raise ValueError("Room is full")
            
            # 添加玩家
            room.players.append(user_id)
            
            # 如果房间满了，自动开始游戏
            if len(room.players) == room.settings["max_players"]:
                room.status = RoomStatus.PLAYING
            
            return room
    
    async def leave_room(self, room_id: str, user_id: str):
        """玩家离开房间"""
        async with self._lock:
            if room_id not in self._rooms:
                return
            
            room = self._rooms[room_id]
            if user_id in room.players:
                room.players.remove(user_id)
            elif user_id in room.spectators:
                room.spectators.remove(user_id)
    
    async def get_room(self, room_id: str) -> Optional[Room]:
        """根据room_id获取房间"""
        async with self._lock:
            return self._rooms.get(room_id)
    
    async def get_room_by_game_id(self, game_id: str) -> Optional[Room]:
        """根据game_id查找对应的房间"""
        async with self._lock:
            for room in self._rooms.values():
                if room.game_id == game_id:
                    return room
            return None
    
    async def list_available_rooms(self) -> List[Room]:
        """列出所有可加入的房间（状态为WAITING）"""
        async with self._lock:
            return [room for room in self._rooms.values() 
                   if room.status == RoomStatus.WAITING]

# 全局单例
room_manager = RoomManager()
```

**关键点**：
- 房间与游戏一一对应（`room_id` ↔ `game_id`）
- 房间满员时自动开始游戏
- 使用锁保证并发安全

---

## 三、FastAPI 后端服务（新增模块）

### 设计说明
FastAPI 负责：
- 提供 HTTP API 和 WebSocket 接口
- 处理玩家请求和实时通信
- 连接游戏逻辑与网络层

### 3. 新建 `api/main.py`

**架构说明**：
- WebSocket：实时双向通信，用于走子和状态推送
- HTTP API：房间管理、查询等非实时操作
- ConnectionManager：管理 WebSocket 连接，按 `game_id` 分组

**代码实现**：
```python
from fastapi import FastAPI, WebSocket, WebSocketDisconnect, HTTPException
from fastapi.middleware.cors import CORSMiddleware
import json
import uuid
from typing import Dict, List

app = FastAPI(title="五子棋多人对战API")

# CORS配置：允许跨域请求（前端可能在不同域名）
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # 生产环境应该指定具体域名
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

class ConnectionManager:
    """WebSocket连接管理器"""
    
    def __init__(self):
        # 存储每个游戏的所有WebSocket连接
        # game_id -> [websocket1, websocket2, ...]
        self.active_connections: Dict[str, List[WebSocket]] = {}
    
    async def connect(self, websocket: WebSocket, game_id: str):
        """建立WebSocket连接"""
        await websocket.accept()
        if game_id not in self.active_connections:
            self.active_connections[game_id] = []
        self.active_connections[game_id].append(websocket)
        print(f"玩家连接到游戏 {game_id}，当前连接数: {len(self.active_connections[game_id])}")
    
    def disconnect(self, websocket: WebSocket, game_id: str):
        """断开WebSocket连接"""
        if game_id in self.active_connections:
            if websocket in self.active_connections[game_id]:
                self.active_connections[game_id].remove(websocket)
            # 如果该游戏没有连接了，清理
            if len(self.active_connections[game_id]) == 0:
                del self.active_connections[game_id]
    
    async def broadcast_to_game(self, game_id: str, message: dict):
        """向游戏内的所有玩家广播消息"""
        if game_id in self.active_connections:
            # 遍历该游戏的所有连接，发送消息
            for connection in self.active_connections[game_id]:
                try:
                    await connection.send_json(message)
                except Exception as e:
                    # 如果发送失败（连接已断开），忽略
                    print(f"发送消息失败: {e}")

manager = ConnectionManager()

@app.websocket("/ws/game/{game_id}")
async def websocket_endpoint(websocket: WebSocket, game_id: str):
    """
    WebSocket端点：处理实时游戏通信
    玩家通过这个端点连接，发送走子请求，接收状态更新
    """
    await manager.connect(websocket, game_id)
    
    try:
        while True:
            # 接收客户端消息
            data = await websocket.receive_text()
            message = json.loads(data)
            
            # 根据消息类型处理
            if message["type"] == "make_move":
                # 处理走子请求
                from tools.gomoku_game import make_move, get_game_board
                
                # 执行走子（需要传入game_id）
                result = await make_move(
                    game_id, 
                    message["row"], 
                    message["col"]
                )
                
                # 获取最新游戏状态
                board = await get_game_board(game_id)
                
                # 广播状态更新给所有玩家
                await manager.broadcast_to_game(game_id, {
                    "type": "game_state_update",
                    "game_id": game_id,
                    "board_state": board.get_board_json(),
                    "current_player": board.current_player.value,
                    "move_result": result,
                    "game_over": board.game_over,
                    "winner": board.winner.value if board.winner else None
                })
            
            elif message["type"] == "ping":
                # 心跳检测
                await websocket.send_json({"type": "pong"})
                
    except WebSocketDisconnect:
        # 客户端断开连接
        manager.disconnect(websocket, game_id)
        print(f"玩家断开连接，游戏 {game_id}")

@app.post("/api/rooms")
async def create_room(creator_id: str, board_size: int = 15):
    """
    创建新房间
    返回room_id和game_id，前端用这些ID进行后续操作
    """
    from core.room_manager import room_manager
    from tools.gomoku_game import init_game
    
    # 生成唯一ID
    room_id = str(uuid.uuid4())
    game_id = str(uuid.uuid4())
    
    # 创建游戏实例
    await init_game(game_id, board_size)
    
    # 创建房间
    room = await room_manager.create_room(room_id, creator_id, game_id)
    
    return {
        "room_id": room_id,
        "game_id": game_id,
        "status": "created",
        "message": "房间创建成功"
    }

@app.post("/api/rooms/{room_id}/join")
async def join_room(room_id: str, user_id: str):
    """玩家加入房间"""
    from core.room_manager import room_manager
    
    try:
        room = await room_manager.join_room(room_id, user_id)
        return {
            "room_id": room.room_id,
            "game_id": room.game_id,
            "players": room.players,
            "status": room.status.value
        }
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))

@app.get("/api/games/{game_id}/state")
async def get_game_state(game_id: str):
    """获取游戏当前状态（HTTP接口，用于查询）"""
    from tools.gomoku_game import get_game_board
    
    try:
        board = await get_game_board(game_id)
        return board.get_board_json()
    except ValueError as e:
        raise HTTPException(status_code=404, detail=str(e))

@app.get("/api/rooms")
async def list_rooms():
    """列出所有可加入的房间"""
    from core.room_manager import room_manager
    rooms = await room_manager.list_available_rooms()
    return [{
        "room_id": room.room_id,
        "game_id": room.game_id,
        "players": room.players,
        "status": room.status.value
    } for room in rooms]

if __name__ == "__main__":
    import uvicorn
    # 启动服务器
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

**关键点**：
- WebSocket 用于实时通信，HTTP API 用于管理操作
- ConnectionManager 按 `game_id` 管理连接，支持广播
- 走子后自动广播状态更新

---

## 四、修改工具函数支持 game_id

### 问题说明
现有工具函数（如 `make_move`、`get_board_state`）使用全局单例，需要改为支持 `game_id`。

### 4. 修改 `tools/gomoku_game.py` 中的所有函数

**改动说明**：
- 所有函数添加 `game_id` 参数
- 函数改为异步（`async def`）
- 通过 `game_id` 获取对应的游戏实例

**需要修改的函数**：
```python
# 改动前
def make_move(row: int, col: int) -> str:
    board = get_current_board()  # 使用全局单例
    # ...

def get_board_state() -> str:
    board = get_current_board()
    # ...

def save_game(filepath: str) -> str:
    board = get_current_board()
    # ...
```

```python
# 改动后：所有函数都需要game_id参数
async def make_move(game_id: str, row: int, col: int) -> str:
    board = await get_game_board(game_id)  # 根据game_id获取
    # ... 原有逻辑不变

async def get_board_state(game_id: str) -> str:
    board = await get_game_board(game_id)
    return board.get_board_state()

async def save_game(game_id: str, filepath: str) -> str:
    board = await get_game_board(game_id)
    # ...
```

### 5. 修改 `agent_builder.py` 中的工具定义

**改动说明**：
- `build_tools()` 需要接收 `game_id` 参数
- 所有工具函数都需要传递 `game_id`
- 工具函数内部调用时传入 `game_id`

**代码改动**：
```python
# 改动前
def build_tools() -> List[Tool]:
    return [
        Tool(
            name="makeMove",
            func=lambda pos: _parse_and_make_move(pos),  # 没有game_id
        ),
        # ...
    ]

def _parse_and_make_move(pos_str: str) -> str:
    # ...
    return make_move(row, col)  # 调用时没有game_id
```

```python
# 改动后：build_tools需要game_id参数
def build_tools(game_id: str) -> List[Tool]:  # 添加game_id参数
    return [
        Tool(
            name="initGame",
            description="初始化游戏（已自动初始化，无需调用）",
            func=lambda _: f"游戏 {game_id} 已初始化",
        ),
        Tool(
            name="makeMove",
            description="在棋盘上落子",
            func=lambda pos: _parse_and_make_move(game_id, pos),  # 传递game_id
        ),
        Tool(
            name="getBoardState",
            description="获取当前棋盘状态",
            func=lambda _: asyncio.run(get_board_state(game_id)),  # 传递game_id
        ),
        # ... 其他工具也要传递game_id
    ]

def _parse_and_make_move(game_id: str, pos_str: str) -> str:
    """解析位置字符串并执行走子"""
    try:
        pos_str = pos_str.strip()
        if ',' in pos_str:
            parts = pos_str.split(',')
        else:
            parts = pos_str.split()
        
        if len(parts) < 2:
            return "错误：需要提供行和列坐标"
        
        row = int(parts[0].strip())
        col = int(parts[1].strip())
        # 调用时传递game_id
        return asyncio.run(make_move(game_id, row, col))
    except Exception as e:
        return f"走子失败: {e}"

# build_agent也需要修改
def build_agent(game_id: str, difficulty: str = "intermediate") -> AgentExecutor:
    # ...
    tools = build_tools(game_id)  # 传递game_id
    # ...
```

**关键点**：
- 所有工具函数都需要 `game_id` 参数
- 工具函数内部调用游戏逻辑时传递 `game_id`
- 如果函数是异步的，需要用 `asyncio.run()` 包装

---

## 五、身份验证系统（新增模块）

### 设计说明
身份验证用于：
- 识别用户身份
- 防止未授权操作
- 记录操作者

### 6. 新建 `auth/jwt_handler.py`

**JWT 说明**：
- 无状态，服务器不存储会话
- Token 包含用户信息，客户端携带
- 适合分布式系统

**代码实现**：
```python
import jwt
from datetime import datetime, timedelta
from typing import Optional

# 密钥（生产环境应该从环境变量读取）
SECRET_KEY = "your-secret-key-change-in-production"
ALGORITHM = "HS256"

def create_token(user_id: str, expires_hours: int = 24) -> str:
    """
    创建JWT Token
    user_id: 用户ID
    expires_hours: Token过期时间（小时）
    """
    payload = {
        "user_id": user_id,
        "exp": datetime.utcnow() + timedelta(hours=expires_hours),
        "iat": datetime.utcnow()  # 签发时间
    }
    return jwt.encode(payload, SECRET_KEY, algorithm=ALGORITHM)

def verify_token(token: str) -> Optional[str]:
    """
    验证JWT Token
    返回user_id，如果Token无效则返回None
    """
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        return payload.get("user_id")
    except jwt.ExpiredSignatureError:
        # Token已过期
        return None
    except jwt.InvalidTokenError:
        # Token无效
        return None

@app.post("/api/auth/login")
async def login(username: str, password: str):
    """
    用户登录接口（简化版，实际应该验证密码）
    返回JWT Token
    """
    # 实际应该从数据库验证用户名密码
    # 这里简化处理
    user_id = username  # 假设用户名就是user_id
    
    token = create_token(user_id)
    return {
        "token": token,
        "user_id": user_id,
        "expires_in": 24 * 3600  # 24小时
    }
```

### 7. 在 API 中添加认证中间件

**改动说明**：
- 创建依赖函数验证 Token
- 在需要认证的接口使用该依赖
- WebSocket 连接时也验证 Token

**代码实现**：
```python
from fastapi import Depends, HTTPException, Header, WebSocket
from auth.jwt_handler import verify_token

async def get_current_user(authorization: str = Header(None)):
    """
    认证依赖函数
    从HTTP Header中提取Token并验证
    """
    if not authorization:
        raise HTTPException(status_code=401, detail="缺少认证Token")
    
    # 提取Token（格式：Bearer <token>）
    try:
        scheme, token = authorization.split()
        if scheme.lower() != "bearer":
            raise HTTPException(status_code=401, detail="认证格式错误")
    except ValueError:
        raise HTTPException(status_code=401, detail="认证格式错误")
    
    user_id = verify_token(token)
    if not user_id:
        raise HTTPException(status_code=401, detail="Token无效或已过期")
    
    return user_id

async def get_user_from_websocket(websocket: WebSocket) -> Optional[str]:
    """
    从WebSocket连接中获取用户ID
    WebSocket连接时，客户端应该在连接URL或首次消息中传递Token
    """
    # 方法1：从查询参数获取Token
    token = websocket.query_params.get("token")
    if token:
        return verify_token(token)
    
    # 方法2：从首次消息获取Token
    # 客户端连接后先发送 {"type": "auth", "token": "..."}
    return None

# 在需要认证的接口使用
@app.post("/api/rooms")
async def create_room(
    creator_id: str = Depends(get_current_user),  # 自动验证Token
    board_size: int = 15
):
    # creator_id已经从Token中获取，无需再传
    # ...

@app.websocket("/ws/game/{game_id}")
async def websocket_endpoint(websocket: WebSocket, game_id: str):
    # 验证Token
    user_id = await get_user_from_websocket(websocket)
    if not user_id:
        await websocket.close(code=1008, reason="未授权")
        return
    
    await manager.connect(websocket, game_id)
    # ...
```

**关键点**：
- HTTP API 使用 Header 中的 Token
- WebSocket 从查询参数或首次消息获取 Token
- 未授权请求返回 401

---

## 六、数据持久化（新增模块）

### 设计说明
数据持久化用于：
- 保存游戏历史
- 支持复盘和分析
- 防止数据丢失

### 8. 新建 `db/models.py`（SQLAlchemy ORM 模型）

**数据库设计**：
- `games`：游戏基本信息
- `moves`：每一步走子记录
- `rooms`：房间信息

**代码实现**：
```python
from sqlalchemy import Column, String, Integer, DateTime, ForeignKey, JSON
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
from datetime import datetime

Base = declarative_base()

class Game(Base):
    """游戏表"""
    __tablename__ = "games"
    
    game_id = Column(String, primary_key=True)
    room_id = Column(String, index=True)
    player1_id = Column(String)
    player2_id = Column(String)
    status = Column(String)  # "playing", "finished"
    winner = Column(String, nullable=True)
    board_size = Column(Integer, default=15)
    created_at = Column(DateTime, default=datetime.now)
    finished_at = Column(DateTime, nullable=True)
    
    # 关联关系
    moves = relationship("Move", back_populates="game", cascade="all, delete-orphan")

class Move(Base):
    """走子记录表"""
    __tablename__ = "moves"
    
    move_id = Column(Integer, primary_key=True, autoincrement=True)
    game_id = Column(String, ForeignKey("games.game_id"), index=True)
    player_id = Column(String)
    row = Column(Integer)
    col = Column(Integer)
    move_number = Column(Integer)  # 第几步
    timestamp = Column(DateTime, default=datetime.now)
    board_state = Column(JSON, nullable=True)  # 可选：保存走子后的棋盘状态
    
    # 关联关系
    game = relationship("Game", back_populates="moves")

class Room(Base):
    """房间表（可选，也可以只存在内存中）"""
    __tablename__ = "rooms"
    
    room_id = Column(String, primary_key=True)
    game_id = Column(String, unique=True, index=True)
    creator_id = Column(String)
    players = Column(JSON)  # 存储玩家ID列表
    status = Column(String)
    created_at = Column(DateTime, default=datetime.now)
```

### 9. 新建 `db/database.py`（数据库连接）

**代码实现**：
```python
from sqlalchemy import create_engine
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker
from db.models import Base

# 数据库URL（PostgreSQL）
DATABASE_URL = "postgresql+asyncpg://user:password@localhost/gomoku"

# 创建异步引擎
engine = create_async_engine(DATABASE_URL, echo=True)

# 创建异步会话工厂
AsyncSessionLocal = sessionmaker(
    engine, class_=AsyncSession, expire_on_commit=False
)

async def init_db():
    """初始化数据库，创建所有表"""
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)

async def get_db():
    """获取数据库会话（依赖注入）"""
    async with AsyncSessionLocal() as session:
        try:
            yield session
        finally:
            await session.close()
```

### 10. 在走子时保存数据

**改动说明**：
- 走子成功后保存到数据库
- 游戏结束时更新游戏状态
- 使用异步数据库操作

**代码改动**：
```python
# 在 tools/gomoku_game.py 的 make_move 函数中添加
from db.models import Game, Move
from db.database import AsyncSessionLocal

async def make_move(game_id: str, row: int, col: int, user_id: str) -> str:
    """走子函数，添加数据库保存"""
    board = await get_game_board(game_id)
    
    # ... 原有走子逻辑 ...
    
    # 保存到数据库
    async with AsyncSessionLocal() as db:
        # 保存走子记录
        move = Move(
            game_id=game_id,
            player_id=user_id,
            row=row,
            col=col,
            move_number=len(board.move_history),
            board_state=board.get_board_json()  # 可选：保存完整状态
        )
        db.add(move)
        
        # 如果游戏结束，更新游戏状态
        if board.game_over:
            game = await db.get(Game, game_id)
            if game:
                game.status = "finished"
                game.winner = board.winner.value if board.winner else None
                game.finished_at = datetime.now()
        
        await db.commit()
    
    return result

# 创建游戏时也要保存
async def init_game(game_id: str, size: int = 15, 
                   player1_id: str = None, player2_id: str = None) -> str:
    """初始化游戏，同时保存到数据库"""
    # ... 原有逻辑 ...
    
    # 保存到数据库
    async with AsyncSessionLocal() as db:
        game = Game(
            game_id=game_id,
            player1_id=player1_id,
            player2_id=player2_id,
            status="playing",
            board_size=size
        )
        db.add(game)
        await db.commit()
    
    return result
```

**关键点**：
- 使用异步数据库操作
- 走子记录包含完整信息
- 游戏结束时更新状态

---

## 七、安装依赖

### 11. 更新 `requirements.txt`

**新增依赖说明**：
- FastAPI：Web 框架
- uvicorn：ASGI 服务器
- websockets：WebSocket 支持
- python-jose：JWT 处理
- sqlalchemy：ORM
- asyncpg：PostgreSQL 异步驱动
- aioredis：Redis 异步客户端（可选，用于缓存和消息队列）

**requirements.txt**：
```txt
# 原有依赖
langchain
langchain-openai
python-dotenv
httpx

# 新增依赖
fastapi>=0.104.0
uvicorn[standard]>=0.24.0
websockets>=12.0
python-jose[cryptography]>=3.3.0
passlib[bcrypt]>=1.7.4
sqlalchemy>=2.0.0
asyncpg>=0.29.0
aioredis>=2.0.1
pymilvus>=2.3.0  # 向量数据库（可选）
```

---

## 八、启动和使用

### 12. 启动服务器

**启动步骤**：
1. 安装依赖：`pip install -r requirements.txt`
2. 初始化数据库：运行 `init_db()` 创建表
3. 启动服务器：`python api/main.py` 或 `uvicorn api.main:app --reload`

**测试接口**：
```bash
# 创建房间
curl -X POST "http://localhost:8000/api/rooms?creator_id=user1&board_size=15"

# 获取游戏状态
curl "http://localhost:8000/api/games/{game_id}/state"

# WebSocket连接（使用wscat工具测试）
wscat -c "ws://localhost:8000/ws/game/{game_id}?token=your_token"
```

---

## 总结

核心改动：
1. 状态管理：单例 → 字典映射（`game_id`）
2. 房间管理：新增 `RoomManager`
3. 网络层：新增 FastAPI + WebSocket
4. 工具函数：添加 `game_id` 参数
5. 认证：JWT 验证
6. 持久化：数据库保存